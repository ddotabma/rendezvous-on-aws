import pandas as pd
from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
import json
from io import BytesIO
import pickle
import boto3
import pandas as pd
from shared_modules.response_model import ModelResponse, BostonEvent, ModelResult, ModelError
from dataclasses import asdict
import time
import traceback
from typing import List

client = boto3.client('sns')
kinesis = boto3.client("kinesis")
s3_resource = boto3.resource("s3")
s3_client = boto3.client("s3")


# :Number of Instances: 506

# :Number of Attributes: 13 numeric/categorical predictive. Median Value (attribute 14) is usually the target.
#
# :Attribute Information (in order):
#     - CRIM     per capita crime rate by town
#     - ZN       proportion of residential land zoned for lots over 25,000 sq.ft.
#     - INDUS    proportion of non-retail business acres per town
#     - CHAS     Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)
#     - NOX      nitric oxides concentration (parts per 10 million)
#     - RM       average number of rooms per dwelling
#     - AGE      proportion of owner-occupied units built prior to 1940
#     - DIS      weighted distances to five Boston employment centres
#     - RAD      index of accessibility to radial highways
#     - TAX      full-value property-tax rate per $10,000
#     - PTRATIO  pupil-teacher ratio by town
#     - B        1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
#     - LSTAT    % lower status of the population
#     - MEDV     Median value of owner-occupied homes in $1000's
#
# :Missing Attribute Values: None
#
# :Creator: Harrison, D. and Rubinfeld, D.L.


def train(test_size, random_state, model_name, bucket):
    try:
        with BytesIO() as data:
            bucket.download_fileobj(f"{model_name}.pkl", data)
            data.seek(0)  # move back to the beginning after writing
            return pickle.load(data)
    except Exception as e:
        print(e)
        boston = load_boston()
        boston_df = pd.DataFrame(boston.data, columns=boston.feature_names)

        boston_df['Price'] = boston.target
        newX = boston_df.drop('Price', axis=1)
        newY = boston_df['Price']
        X_train, X_test, y_train, y_test = train_test_split(newX, newY, test_size=test_size, random_state=random_state)

        lr = RandomForestRegressor()
        lr.fit(X_train, y_train)
        bucket.put_object(Key=f"{model_name}.pkl",
                          Body=pickle.dumps(lr))
        return lr


def score(model, test_size, random_state, model_name, bucket):
    try:
        with BytesIO() as data:
            bucket.download_fileobj(f"{model_name}_score.json", data)
            data.seek(0)  # move back to the beginning after writing
            scores = json.load(data)
        return scores[0], scores[1]
    except Exception as e:
        print(e)
        boston = load_boston()
        boston_df = pd.DataFrame(boston.data, columns=boston.feature_names)

        boston_df['Price'] = boston.target
        newX = boston_df.drop('Price', axis=1)
        newY = boston_df['Price']
        X_train, X_test, y_train, y_test = train_test_split(newX, newY, test_size=test_size, random_state=random_state)
        train_score, test_score = model.score(X_train, y_train), model.score(X_test, y_test)
        bucket.put_object(Key=f"{model_name}_score.json",
                          Body=json.dumps((train_score, test_score), ensure_ascii=False))

        return model.score(X_train, y_train), model.score(X_test, y_test)


def predict_prices(model, records: List[BostonEvent]):
    """Predict prices for all received requests from SQS"""
    return model.predict(pd.DataFrame.from_records([asdict(i.body.Message.data.request) for i in records]))


def run_model(model, model_name, test_score, train_score, sqs_event):
    """Run the randomforest prediction. Send results or errors to kinesis."""

    records = [BostonEvent(**i) for i in sqs_event["Records"]]
    try:
        prices = predict_prices(model, records)
        raise Exception("test")
        for price, record in zip(prices, records):
            message = record.body.Message
            now = time.time()

            model_response = ModelResponse(  # create instance of standardized response
                uuid=message.uuid,
                start_time=now,
                duration=time.time() - now,
                time_after_rendezvous=time.time() - message.rendezvous_time,
                model=model_name,
                results=asdict(ModelResult(test_score=test_score,
                                           train_score=train_score,
                                           price=price)))

            kinesis.put_record(StreamName=message.data.kinesis_stream,
                               PartitionKey=message.uuid,
                               Data=model_response.json())

            print("DONE")
            return price  # unused
    except Exception as e:
        data = ModelError(traceback=traceback.format_exc(),
                                           message=str(e), uuid=records[0].body.Message.uuid).json()
        print(data, len(records))
        kinesis.put_record(StreamName=records[0].body.Message.data.kinesis_stream,
                           PartitionKey=records[0].body.Message.uuid,
                           Data=data)
        return 1
