import pandas as pd
from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
import json
from io import BytesIO
import pickle


def train(test_size, random_state, model_name, bucket):
    try:
        with BytesIO() as data:
            bucket.download_fileobj(f"{model_name}.pkl", data)
            data.seek(0)  # move back to the beginning after writing
            return pickle.load(data)
    except Exception as e:
        print(e)
        boston = load_boston()
        boston_df = pd.DataFrame(boston.data, columns=boston.feature_names)

        boston_df['Price'] = boston.target
        newX = boston_df.drop('Price', axis=1)
        newY = boston_df['Price']
        X_train, X_test, y_train, y_test = train_test_split(newX, newY, test_size=test_size, random_state=random_state)

        lr = RandomForestRegressor()
        lr.fit(X_train, y_train)
        bucket.put_object(Key=f"{model_name}.pkl",
                          Body=pickle.dumps(lr))
        return lr


def score(model, test_size, random_state, model_name, bucket):
    try:
        with BytesIO() as data:
            bucket.download_fileobj(f"{model_name}_score.json", data)
            data.seek(0)  # move back to the beginning after writing
            scores = json.load(data)
        return scores[0], scores[1]
    except Exception as e:
        print(e)
        boston = load_boston()
        boston_df = pd.DataFrame(boston.data, columns=boston.feature_names)

        boston_df['Price'] = boston.target
        newX = boston_df.drop('Price', axis=1)
        newY = boston_df['Price']
        X_train, X_test, y_train, y_test = train_test_split(newX, newY, test_size=test_size, random_state=random_state)
        train_score, test_score = model.score(X_train, y_train), model.score(X_test, y_test)
        bucket.put_object(Key=f"{model_name}_score.json",
                          Body=json.dumps((train_score, test_score), ensure_ascii=False))

        return model.score(X_train, y_train), model.score(X_test, y_test)
